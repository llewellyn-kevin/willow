# willow
API Response Factories for Laravel

## Target API
This section defines targets for how the library should be used when the project is finished.

### Responses
This is the API for actually creating fake external API responses.

```php
/**
 * GET Requests
 */

// Get a generated fake resource from requesting a single resource from an API.
WillowFactory::fakeApi()->show();
// Get a generated fake collection from requesting an index of resources from an API.
WillowFactory::fakeApi()->count(3)->index();
// Override specific fields as they are generated by the factory.
WillowFactory::fakeApi()->show([
    'foo' => 'bar',                         // overrides field `foo` to always be "bar"
    'person.name' => 'Montgomery Scott',    // nested fields use same syntax as data_set()
]);

// Add lifecycle functions to transform the data after it is generated.
WillowFactory::fakeApi()->count(3)->afterMaking(function(array $data) { // runs after each resource is made
    $data['value']++;
})->index();
WillowFactory::fakeApi()->count(3)->afterMaking(function(array $data) {
    $data['value']++;
})->afterComposing(function(array $data) {  // runs after the whole response is generated
    data['status'] = 200;
})->index();

/**
 * PUT/PATCH/POST/DELETE Requests
 * PUT functions about the same as POST, but the assumption is the resource will
 * have been updated rather than created. This may alter the response object, but
 * does not alter the API used to interact with the factory.
 *
 * Patch is a synonym for put in this case.
 *
 * Delete is also just a type of update, and consequently also uses the same API.
 * Just like with put or post, the different method call merely allows the user to
 * define seperate make/compose methods for generating the response. Otherwise it
 * is identical API and behavior behind the scenes.
 */

// Get a response based on creating a resource without specifying request data.
WillowFactory::fakeApi()->post();
WillowFactory::fakeApi()->put();
WillowFactory::fakeApi()->patch();
WillowFactory::fakeApi()->delete();
// Manually specify data to pass with request.
WillowFactory::fakeApi()->requestData([
    'fname' => 'John',
    'lname' => 'Appleseed',
    'age' => 28,
])->post();
WillowFactory::fakeApi()->requestData(['id' => 10, 'name' => 'John Appleseed'])->put();
WillowFactory::fakeApi()->requestData(['id' => 10, 'name' => 'John Appleseed'])->patch();
WillowFactory::fakeApi()->requestData(['id' => 10, 'name' => 'John Appleseed'])->delete();
// Use a request data factory (in this case called `person`) to generate data to pass with request.
WillowFactory::fakeApi()->count(3)->sendsPerson()->post();
WillowFactory::fakeApi()->count(3)->sendsPerson()->put();
WillowFactory::fakeApi()->count(3)->sendsPerson()->patch();
WillowFactory::fakeApi()->count(3)->sendsPerson()->delete();

// Can use lifecycle hooks with any kind of response.
WillowFactory::fakeApi()->count(3)->sendsPerson()->afterMaking(function(array $data) {
    $data['value']++;
})->post();
```

### Factory Definition
This is how to define a response factory that can be consumed by the API specified above.

```php
<?php

namespace Database\Factories\Api\Responses;

use Willow\Factory;

class FakeApi extends Factory
{
    /**
     * The name that will be used to access this factory from the Willow facade.
     * The one shown here will be the default unless overridden here.
     * @var string
     */
    protected static $accessor = 'fakeApi';

    /**
     * Determines how the API response data should be formatted before
     * being returned.
     * @param array $generated
     *
     * @return array
     */
    public function compose(array $generated): array
    {
        return [
            'status' => $this->autoStatus,  // Base the status code on the request method used.
            'response' => $generated,       // The collection/resource
        ];
    }

    /**
     * Mocks a simple API response that returns a quote.
     * @return array
     */
    public function definition(): array
    {
        return [
            'quote' => $this->faker->bs(),  // The class has a faker instance.
            'source' => [
                'name' => $this->faker->name(),
                'age' => rand(21, 65),
            ]
        ];
    }
}
```

### Request Data Factory
Request Data Factories are simple classes. They function like an API factory, but have
no lifecycle hooks, counts, or different methods for accessing. They merely have a definition
method and Faker instance.

```php
<?php

namespace Database\Factories\Api\Requests;

use Willow\RequestDataFactory;

class Person extends RequestDataFactory
{
    /**
     * Mocks a person object that can be used for an external API request.
     * @return array
     */
    public function definition(): array
    {
        return [
            'name' => $this->faker->name(),
            'age' => rand(21, 65),
        ];
    }
}
```
