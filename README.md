# willow
API Response Factories for Laravel

## Target API
This section defines targets for how the library should be used when the project is finished.

### Responses
This is the API for actually creating fake external API responses.

```php
/**
 * GET Requests
 */

// Get a generated fake resource from requesting a single resource from an API.
WillowFactory::fakeApi()->show();
// Get a generated fake collection from requesting an index of resources from an API.
WillowFactory::fakeApi()->count(3)->index();
// Override specific fields as they are generated by the factory.
WillowFactory::fakeApi()->show([
    'foo' => 'bar',                         // overrides field `foo` to always be "bar"
    'person.name' => 'Montgomery Scott',    // nested fields use same syntax as data_set()
]);

// Add lifecycle functions to transform the data after it is generated.
WillowFactory::fakeApi()->count(3)->afterMaking(function(array $data) { // runs after each resource is made
    $data['value']++;
})->index();
WillowFactory::fakeApi()->count(3)->afterMaking(function(array $data) {
    $data['value']++;
})->afterComposing(function(array $data) {  // runs after the whole response is generated
    data['status'] = 200;
})->index();

/**
 * PUT/PATCH/POST/DELETE Requests
 * PUT functions about the same as POST, but the assumption is the resource will
 * have been updated rather than created. This may alter the response object, but
 * does not alter the API used to interact with the factory.
 *
 * Patch is a synonym for put in this case.
 *
 * Delete is also just a type of update, and consequently also uses the same API.
 * Just like with put or post, the different method call merely allows the user to
 * define seperate make/compose methods for generating the response. Otherwise it
 * is identical API and behavior behind the scenes.
 */

// Get a response based on creating a resource without specifying request data.
WillowFactory::fakeApi()->post();
WillowFactory::fakeApi()->put();
WillowFactory::fakeApi()->patch();
WillowFactory::fakeApi()->delete();
// Manually specify data to pass with request.
WillowFactory::fakeApi()->requestData([
    'fname' => 'John',
    'lname' => 'Appleseed',
    'age' => 28,
])->post();
WillowFactory::fakeApi()->requestData(['id' => 10, 'name' => 'John Appleseed'])->put();
WillowFactory::fakeApi()->requestData(['id' => 10, 'name' => 'John Appleseed'])->patch();
WillowFactory::fakeApi()->requestData(['id' => 10, 'name' => 'John Appleseed'])->delete();
// Use a request data factory (in this case called `person`) to generate data to pass with request.
WillowFactory::fakeApi()->count(3)->sendsPerson()->post();
WillowFactory::fakeApi()->count(3)->sendsPerson()->put();
WillowFactory::fakeApi()->count(3)->sendsPerson()->patch();
WillowFactory::fakeApi()->count(3)->sendsPerson()->delete();

// Can use lifecycle hooks with any kind of response.
WillowFactory::fakeApi()->count(3)->sendsPerson()->afterMaking(function(array $data) {
    $data['value']++;
})->post();
```

### Factory Definition
This is how to define a response factory that can be consumed by the API specified above.

```php
<?php

namespace Database\Factories\Api\Responses;

use Willow\Factory;

class FakeApi extends Factory
{
    /**
     * The name that will be used to access this factory from the Willow facade.
     * The one shown here will be the default unless overridden here.
     * @var string
     */
    protected static $accessor = 'fakeApi';

    /**
     * Determines how the API response data should be formatted before
     * being returned.
     */
    public function compose(array $generated): array
    {
        return [
            'status' => $this->autoStatus,  // Base the status code on the request method used.
            'response' => $generated,       // The collection/resource
        ];
    }

    /**
     * Defines how each resource from the API should be constructed. Could be modified to also
     * just return an instance of a request data factory, to use that definition instead.
     */
    public function definition(): array
    {
        return [
            'quote' => $this->faker->bs(),  // The class has a faker instance.
            'source' => [
                'name' => $this->faker->name(),
                'age' => rand(21, 65),
            ]
        ];
    }
}
```

### Request Data Factory
Request Data Factories are simple classes. They function like an API factory, but have
no lifecycle hooks, counts, or different methods for accessing. They merely have a definition
method and Faker instance.

Potentially add a field that allows the user to make an 'id' field optional. This likely won't
actually be needed, request data for mocked calls rarely needs to be that accurate, but POST
requests usually won't want an ID, but PUT/DELETE does. Maybe nothing that specific, maybe allow
the user to mark any field as optional and just pass in an array of optional fields to include.
But again, this is probably overthinking things. This data doesn't actually get sent anywhere, it
just gets spat back out at the user.

```php
<?php

namespace Database\Factories\Api\Requests;

use Willow\RequestDataFactory;

class Person extends RequestDataFactory
{
    /**
     * Defines how to generate an API request or response representing a model. Can
     * be used for generating POST requests or even used as the definition of an API
     * factory.
     */
    public function definition(): array
    {
        return [
            'name' => $this->faker->name(),
            'age' => rand(21, 65),
        ];
    }
}
```

## Outstanding Questions
These are concepts that need further exploration.
1. Is there a way to logically handle some of the more common requirements for tests? Like instead passing a date into a field when making a response, pass in a keyword like 'past' or 'future' so that it will only generate a date before or after 'now' respectively. This could help when testing to make sure only the proper models show up.
2. Is there a way to support some kind of relationships? eg. including Laravel Models or Request Data Factories.
